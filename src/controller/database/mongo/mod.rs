//! MongoDB connection management

use dotenv;
use futures::stream::TryStreamExt;
use mongodb::bson::doc;
use mongodb::bson::oid::ObjectId;
use mongodb::options::{ClientOptions, FindOptions, FindOneOptions};
use mongodb::Client;

use crate::model::flag::{FeatureFlag, FeatureFlagBuilder};
use crate::model::product::{Product, ProductBuilder};
use crate::model::user::{User, UserBuilder};

/// Given a product name, this will search for and return a fully constructed `Product` from MongoDB wrapped inside of a
/// `Result`.
///
/// If no product is found, will return the result of `Product::default()`.  
///
/// ## Result Error
/// `Result` can contain a MongoDB specific error
pub async fn get_product(product_name: &str) -> Result<Option<Product>, mongodb::error::Error> {
  let client = get_client().await?;

  let db = client.database("data");
  let product_collection = db.collection::<Product>("products");

  let filter = doc! { "name": product_name };
  let find_options = FindOneOptions::builder().sort(doc! { "name": 1 }).build();

  product_collection.find_one(filter, find_options).await
}

/// Given a product name and flag name, this will search for and return a fully constructed `FeatureFlag` from MongoDB
/// wrapped inside of a `Result`.
///
/// If no feature flag is found, will return the result of `FeatureFlag::default()`.  
///
/// ## Result Error
/// `Result` can contain a MongoDB specific error
pub async fn get_feature_flag(product_id: &str, flag_name: &str) -> Result<Option<FeatureFlag>, mongodb::error::Error> {
  let client = get_client().await?;

  let db = client.database("data");
  let features_collection = db.collection::<FeatureFlag>("features");

  let filter = doc! { "name": flag_name, "product_id": product_id };
  let find_options = FindOneOptions::builder().sort(doc! {"name": 1 }).build();

  features_collection.find_one(filter, find_options).await
}

/// Given a user email, this will search for and return a fully constructed `User` from MongoDB wrapped inside of a
/// `Result`.
///
/// If no user is found, will return the result of `User::default()`.  
///
/// ## Result Error
/// `Result` can contain a MongoDB specific error
pub async fn get_user(user_email: &str) -> Result<Option<User>, mongodb::error::Error> {
  let client = get_client().await?;

  let db = client.database("data");
  let user_collection = db.collection::<User>("users");

  let filter = doc! {"email": user_email };
  let find_options = FindOneOptions::builder().sort(doc! { "email": 1}).build();

  user_collection.find_one(filter, find_options).await
}

pub async fn create_product(product_builder: ProductBuilder) -> Result<Product, mongodb::error::Error> {
  let client = get_client().await?;

  let db = client.database("data");
  let products_collection = db.collection::<Product>("products");

  let product_id = products_collection
    .insert_one(product_builder.clone().build(), None)
    .await?
    .inserted_id
    .as_object_id()
    .unwrap_or_else(|| ObjectId::default());

  let product = product_builder.with_id(product_id.to_hex()).build();

  Ok(product)
}

pub async fn create_flag(flag_builder: FeatureFlagBuilder) -> Result<FeatureFlag, mongodb::error::Error> {
  let client = get_client().await?;

  let db = client.database("data");
  let features_collection = db.collection::<FeatureFlag>("features");

  let flag_id = features_collection
    .insert_one(flag_builder.clone().build(), None)
    .await?
    .inserted_id
    .as_object_id()
    .unwrap_or_else(|| ObjectId::default());

  let flag = flag_builder.with_id(flag_id.to_hex()).build();

  Ok(flag)
}

/// Given a `UserBuilder`, this will attempt to create a new `User` and insert them into the database.
///
/// The `User` returned inside of the `Result` will contain the ObjectId generated by MongoDB
///
/// ## Result Error
/// `Result` can contain a MongoDB specific error
pub async fn create_user(user_builder: UserBuilder) -> Result<User, mongodb::error::Error> {
  let client = get_client().await?;

  let db = client.database("data");
  let user_collection = db.collection::<User>("users");

  let user_id = user_collection
    .insert_one(user_builder.clone().build(), None)
    .await?
    .inserted_id
    .as_object_id()
    .unwrap_or_else(|| ObjectId::default());

  let user = user_builder.with_id(user_id.to_hex()).build();

  Ok(user)
}

async fn get_client() -> Result<Client, mongodb::error::Error> {
  dotenv::dotenv().ok();

  let connection_string = match dotenv::var("MONGO_STR") {
    Ok(value) => value,
    Err(e) => {
      panic!("Error getting MongoDB connection string (MONGO_STR): {:?}", e);
    }
  };

  let client_options = ClientOptions::parse(connection_string).await?;

  let client = Client::with_options(client_options)?;

  Ok(client)
}
